<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="initial-scale=1">
		<title>Text-Field Calculator</title>
		<script src="math.js"></script>
		<style>
			html, body {
				height: 100%;
			}

			body {
				margin: 0;
			}

			#container {
				overflow: hidden;
				height: 100%;
			}

			@media (prefers-color-scheme: dark) {
				body {
					background-color: #1e1e1e;
				}
			}
		</style>
	</head>
	<body>

		<div id="container"></div>

		<textarea id="persistance" name="persistance" hidden></textarea>

		<script src="monaco-editor/min/vs/loader.js"></script>
		<script>
			// https://stackoverflow.com/a/34842797/8213163
			const hashCode = s => s.split('').reduce((a,b) => (((a << 5) - a) + b.charCodeAt(0))|0, 0)

			require.config({ paths: { 'vs': 'monaco-editor/min/vs' }});
			require(['vs/editor/editor.main'], function() {
				const baseSuggestions = Object.entries(math)
				.filter(([key, value]) => {
					try {
						math.help(value);
						return true;
					} catch (exception) {
						return false;
					}
				})
				.map(([key, value]) => {
					return {
						label: key,
						kind: typeof value == "function" ? monaco.languages.CompletionItemKind.Function : monaco.languages.CompletionItemKind.Constant,
						insertText: typeof value == "function" ? `${key}($0)` : key,
						insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
						documentation: math.help(value).doc.description
					}
				});

				// Define math language
				monaco.languages.register({ id: "math" });
				monaco.languages.registerCompletionItemProvider("math", {
					provideCompletionItems: function(model, position) {
						const suggestions = [...baseSuggestions];

						for (let i = 1; i < position.lineNumber; i++) {
							const result = lineResults[i - 1];
							if (result == undefined)
								continue;

							suggestions.push(
								{
									label: `line${i}`,
									insertText: `line${i}`,
									kind: monaco.languages.CompletionItemKind.Variable,
									documentation: `The result of line ${i}. (${result})`
								},
								{
									label: `l${i}`,
									insertText: `l${i}`,
									kind: monaco.languages.CompletionItemKind.Variable,
									documentation: `The result of line ${i}. (${result})`
								}
							);
						}

						return {
							suggestions: suggestions
						};
					}
				});
				monaco.languages.setMonarchTokensProvider("math", {
					keywords: [
						'true', 'false'
					],

					operators: [
						'=', '>', '<', '!', '~', '?', ':', '==', '<=', '>=', '!=',
						'&&', '||', '++', '--', '+', '-', '*', '/', '&', '|', '^', '%',
						'<<', '>>', '>>>', '+=', '-=', '*=', '/=', '&=', '|=', '^=',
						'%=', '<<=', '>>=', '>>>='
					],

					ignoreCase: true,
					defaultToken: "invalid",

					symbols: /[=><!~?:&|+\-*\/\^%]+/,
					escapes: /\\(?:[abfnrtv\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,

					tokenizer: {
						root: [
							[
								/[a-z_$\u00C0-\u02AF\u0370-\u03FF\u2100-\u214F][0-9a-z_$\u00C0-\u02AF\u0370-\u03FF\u2100-\u214F]*/u,
								{ cases: { '@keywords': 'keyword',
										   '@default': 'identifier' } }
							],

							[/\d*\.\d+([eE][\-+]?\d+)?/, 'number.float'],
							[/0[xX][0-9a-fA-F]+/, 'number.hex'],
							[/\d+(e\d+)?/, 'number'],

							[/[()[\]]/, '@brackets'],

							[/@symbols/, {
								cases: {
									'@operators': 'operator',
									'@default': ''
								}
							}],

							[/[;,]/, 'delimiter'],

							// strings
							[/"([^"\\]|\\.)*$/, 'string.invalid'],  // non-teminated string
							[/'([^'\\]|\\.)*$/, 'string.invalid'],  // non-teminated string
							[/"/, 'string', '@string_double'],
							[/'/, 'string', '@string_single'],

							[/#.*/, "comment"]
						],

						string_double: [
							[/[^\\"]+/, 'string'],
							[/@escapes/, 'string.escape'],
							[/\\./, 'string.escape.invalid'],
							[/"/, 'string', '@pop']
						],

						string_single: [
							[/[^\\']+/, 'string'],
							[/@escapes/, 'string.escape'],
							[/\\./, 'string.escape.invalid'],
							[/'/, 'string', '@pop']
						]
					}
				});

				var editor = monaco.editor.create(document.getElementById('container'), {
					language: "math",
					value: persistance.value,
					theme: window.matchMedia("(prefers-color-scheme: dark)").matches ? "vs-dark" : "vs",
					mouseWheelZoom: true,
					fontSize: 20,
					wordWrap: "on",
					lineNumbersMinChars: 2
				}, {
					storageService: {
						get() {},
						getBoolean(key) {
							if (key === "expandSuggestionDocs")
								return true;

							return false;
						},
						getNumber() {},
						store() {},
						onWillSaveState() {},
						onDidChangeStorage() {},
						remove() {}
					}
				});

				// Actions
				editor.addAction({
					id: "replace-result-all",
					label: "Replace Everything with the Result",
					keybindings: [
						monaco.KeyCode.Tab
					],
					contextMenuGroupId: "1_modification",
					run: function() {
						editor.pushUndoStop();
						editor.executeEdits("replace-result-all", [{
							range: new monaco.Range(1, 1, Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER),
							text: math.evaluate(editor.getValue()).toString()
						}]);
						editor.setPosition(new monaco.Position(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER));
					}
				});

				editor.addAction({
					id: "replace-result-line",
					label: "Replace Line with it's Result",
					keybindings: [
						monaco.KeyMod.Shift | monaco.KeyCode.Tab
					],
					contextMenuGroupId: "1_modification",
					run: function() {;
						const lineNumber = editor.getPosition().lineNumber;
						const result = lineResults[lineNumber - 1];
						if (result == null)
							return;

						editor.pushUndoStop();
						editor.executeEdits("replace-result-line", [{
							range: new monaco.Range(lineNumber, 1, lineNumber, Number.MAX_SAFE_INTEGER),
							text: result.toString()
						}]);
						editor.setPosition(new monaco.Position(lineNumber, Number.MAX_SAFE_INTEGER));
					}
				});

				editor.addAction({
					id: "insert-result-all",
					label: "Insert a New Line with the Result",
					keybindings: [],
					contextMenuGroupId: "1_modification",
					run: function() {
						const lineNumber = editor.getPosition().lineNumber;

						editor.pushUndoStop();
						editor.executeEdits("insert-result-all", [{
							range: new monaco.Range(lineNumber, Number.MAX_SAFE_INTEGER, lineNumber, Number.MAX_SAFE_INTEGER),
							text: "\n" + math.evaluate(editor.getValue()).toString()
						}]);
						editor.setPosition(new monaco.Position(lineNumber, Number.MAX_SAFE_INTEGER));
					}
				});

				editor.addAction({
					id: "insert-result-line",
					label: "Insert a New Line with the Result of the Current Line",
					keybindings: [],
					contextMenuGroupId: "1_modification",
					run: function() {;
						const lineNumber = editor.getPosition().lineNumber;
						const result = lineResults[lineNumber - 1];
						if (result == null)
							return;

						editor.pushUndoStop();
						editor.executeEdits("insert-result-line", [{
							range: new monaco.Range(lineNumber, Number.MAX_SAFE_INTEGER, lineNumber, Number.MAX_SAFE_INTEGER),
							text: "\n" + result.toString()
						}]);
						editor.setPosition(new monaco.Position(lineNumber, Number.MAX_SAFE_INTEGER));
					}
				});

				window.editor = editor;

				editor.onDidChangeModelContent((event) => update());
				window.addEventListener("resize", () => editor.layout());

				let decorationKeys = new Set();
				function makeDecoration(key, options) {
					if (!decorationKeys.has(key)) {
						editor._codeEditorService.registerDecorationType("result", key, options);

						decorationKeys.add(key);
					}

					return editor._codeEditorService.resolveDecorationOptions(key, true);
				}

				math.config({
					number: "BigNumber",
					precision: 10
				});

				let oldDecorations = [];
				let lineResults = [];
				function update() {
					const parser = math.parser();
					const lines = editor.getValue().split("\n");
					const decorators = [];
					const usedKeys = new Set();
					const markers = [];

					lineResults = [];

					// Parse each line of math
					for (let [index, line] of lines.entries()) {
						let result;
						try {
							result = parser.evaluate(line.trim());
						} catch (exception) {
							// Add any exceptions as markers
							markers.push({
								message: exception.message,
								startColumn: exception.char ?? 1,
								endColumn: exception.char ?? Number.MAX_SAFE_INTEGER,
								startLineNumber: index + 1,
								endLineNumber: index + 1
							});
							continue;
						}

						if (result == undefined || typeof result == "function")
							continue;

						lineResults[index] = result;

						parser.set(`l${index + 1}`, result);
						parser.set(`line${index + 1}`, result);

						// Add any results are decorators.
						const key = hashCode(result.toString());
						decorators.push({ range: new monaco.Range(index + 1, Number.MAX_SAFE_INTEGER, index + 1, Number.MAX_SAFE_INTEGER), options: makeDecoration(key, {
							after: {
								color: "gray",
								margin: "0 0 0 1em",
								textDecoration: "none",
								contentText: result.toString()
							}
						})});

						usedKeys.add(key);
					}

					// Delta the new decorators
					oldDecorations = editor.deltaDecorations(oldDecorations, decorators);

					// Cleanup old keys
					for (const key of decorationKeys) {
						if (!usedKeys.has(key)) {
							editor._codeEditorService.removeDecorationType(key);
							decorationKeys.delete(key);
						}
					}

					// Set markers
					monaco.editor.setModelMarkers(editor.getModel(), "math", markers);

					// Put text in hidden textarea to persist data
					persistance.value = editor.getValue();
				}

				update();
			});
		</script>
	</body>
</html>