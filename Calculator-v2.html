<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="initial-scale=1">
		<link rel="icon" href="favicon.ico">
		<title>Text-Field Calculator</title>
		<link rel="stylesheet" href="main.css">
		<script src="math.js"></script>
		<style>
			html, body, .content {
				height: 100%;
			}

			body {
				margin: 0;
			}

			.content {
				display: grid;
				grid-template-rows: auto 1fr auto;
			}

			#container {
				overflow: hidden;
			}

			.header, footer {
				margin: 10px;
			}

			@media (prefers-color-scheme: dark) {
				body {
					background-color: #1e1e1e;
				}
			}
		</style>
	</head>
	<body>
		<div class="content">
			<div class="header">
				<b>Text-Field Calculator</b>
				<a href="Calculator.html">Version 1</a>
			</div>
			<div id="container"></div>

			<textarea id="persistance" name="persistance" hidden></textarea>

			<footer>
				<a href="https://mathjs.org/docs/index.html#documentation">Documentation</a>
				<a href="https://github.com/samfundev/TextFieldCalculator">Source</a>
			</footer>
		</div>

		<script src="monaco-editor/min/vs/loader.js"></script>
		<script>
			// https://stackoverflow.com/a/34842797/8213163
			const hashCode = s => s.split('').reduce((a,b) => (((a << 5) - a) + b.charCodeAt(0))|0, 0)

			require.config({ paths: { 'vs': 'monaco-editor/min/vs' }});
			require(['vs/editor/editor.main'], function() {
				const baseSuggestions = Object.entries(math)
				.filter(([key, value]) => {
					try {
						math.help(value);
						return true;
					} catch (exception) {
						return false;
					}
				})
				.map(([key, value]) => {
					const doc = math.help(value).doc;

					let count = 1;
					function snippetify(_, before, middle) {
						return `${before}$\{${count++}:${middle}\}`;
					}

					return {
						label: key,
						kind: typeof value == "function" ? monaco.languages.CompletionItemKind.Function : monaco.languages.CompletionItemKind.Constant,
						insertText: typeof value == "function" ? doc.syntax[0].replaceAll(/(\(|, )(.+?)(?=\)|, )/g, snippetify) : key,
						insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
						documentation: doc.description
					}
				});

				function suggestionAliases(suggestion, aliases)
				{
					return aliases.map(alias => {
						return { label: alias, insertText: alias, ...suggestion };
					})
				}

				// Define math language
				monaco.languages.register({ id: "math" });
				monaco.languages.registerCompletionItemProvider("math", {
					provideCompletionItems: function(model, position) {
						const suggestions = [...baseSuggestions];

						// Add line# suggestions
						for (let i = 1; i < position.lineNumber; i++) {
							const result = lineResults[i - 1];
							if (result == undefined)
								continue;

							suggestions.push(...suggestionAliases(
								{
									kind: monaco.languages.CompletionItemKind.Variable,
									documentation: `The result of line ${i}. (${result})`
								},
								[`line${i}`, `l${i}`]
							));
						}

						// Add previous/answer suggestions
						if (position.lineNumber !== 1)
						{
							const previousResult = lineResults[position.lineNumber - 2];
							if (previousResult != undefined)
							{
								suggestions.push(...suggestionAliases(
									{
										kind: monaco.languages.CompletionItemKind.Variable,
										documentation: `The result of the previous line. (${previousResult})`
									},
									["prev", "previous", "ans", "answer"]
								));
							}
						}

						return {
							suggestions: suggestions
						};
					}
				});
				monaco.languages.setMonarchTokensProvider("math", {
					keywords: [
						'true', 'false'
					],

					operators: [
						'=', '>', '<', '!', '~', '?', ':', '==', '<=', '>=', '!=',
						'&&', '||', '++', '--', '+', '-', '*', '/', '&', '|', '^', '%',
						'<<', '>>', '>>>', '+=', '-=', '*=', '/=', '&=', '|=', '^=',
						'%=', '<<=', '>>=', '>>>='
					],

					defaultToken: "invalid",

					symbols: /[=><!~?:&|+\-*\/\^%]+/,
					escapes: /\\(?:[abfnrtv\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,

					tokenizer: {
						root: [
							[
								/[a-z_$\u00C0-\u02AF\u0370-\u03FF\u2100-\u214F][0-9a-z_$\u00C0-\u02AF\u0370-\u03FF\u2100-\u214F]*/u,
								{ cases: { '@keywords': 'keyword',
										   '@default': 'identifier' } }
							],

							[/\d*\.\d+([eE][\-+]?\d+)?/, 'number.float'],
							[/0x[0-9a-fA-F]+(\.[0-9a-fA-F]+)?/, 'number.hex'],
							[/0b[01]+(\.[01]+)?/, 'number.binary'],
							[/0o[0-7]+(\.[0-7]+)?/, 'number.octal'],
							[/\d+(e\d+)?/, 'number'],

							[/[()[\]]/, '@brackets'],

							[/@symbols/, {
								cases: {
									'@operators': 'operator',
									'@default': ''
								}
							}],

							[/[;,]/, 'delimiter'],

							// strings
							[/"([^"\\]|\\.)*$/, 'string.invalid'],  // non-teminated string
							[/'([^'\\]|\\.)*$/, 'string.invalid'],  // non-teminated string
							[/"/, 'string', '@string_double'],
							[/'/, 'string', '@string_single'],

							[/#.*/, "comment"]
						],

						string_double: [
							[/[^\\"]+/, 'string'],
							[/@escapes/, 'string.escape'],
							[/\\./, 'string.escape.invalid'],
							[/"/, 'string', '@pop']
						],

						string_single: [
							[/[^\\']+/, 'string'],
							[/@escapes/, 'string.escape'],
							[/\\./, 'string.escape.invalid'],
							[/'/, 'string', '@pop']
						]
					}
				});

				var editor = monaco.editor.create(document.getElementById('container'), {
					language: "math",
					value: persistance.value,
					theme: window.matchMedia("(prefers-color-scheme: dark)").matches ? "vs-dark" : "vs",
					mouseWheelZoom: true,
					fontSize: 20,
					wordWrap: "on",
					lineNumbersMinChars: 2
				}, {
					storageService: {
						get() {},
						getBoolean(key) {
							if (key === "expandSuggestionDocs")
								return true;

							return false;
						},
						getNumber() {},
						store() {},
						onWillSaveState() {},
						onDidChangeStorage() {},
						remove() {}
					}
				});

				// Actions
				editor.addAction({
					id: "replace-result-all",
					label: "Replace Everything with the Result",
					keybindings: [
						monaco.KeyCode.Tab
					],
					precondition: "!inSnippetMode",
					contextMenuGroupId: "1_modification",
					run: function() {
						if (finalResult == null)
							return;

						editor.pushUndoStop();
						editor.executeEdits("replace-result-all", [{
							range: new monaco.Range(1, 1, Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER),
							text: finalResult.toString()
						}]);
						editor.setPosition(new monaco.Position(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER));
					}
				});

				editor.addAction({
					id: "replace-result-line",
					label: "Replace Line with it's Result",
					keybindings: [
						monaco.KeyMod.Shift | monaco.KeyCode.Tab
					],
					precondition: "!inSnippetMode",
					contextMenuGroupId: "1_modification",
					run: function() {
						const lineNumber = editor.getPosition().lineNumber;
						const result = lineResults[lineNumber - 1];
						if (result == null)
							return;

						editor.pushUndoStop();
						editor.executeEdits("replace-result-line", [{
							range: new monaco.Range(lineNumber, 1, lineNumber, Number.MAX_SAFE_INTEGER),
							text: result.toString()
						}]);
						editor.setPosition(new monaco.Position(lineNumber, Number.MAX_SAFE_INTEGER));
					}
				});

				editor.addAction({
					id: "insert-result-all",
					label: "Insert a New Line with the Result",
					keybindings: [],
					contextMenuGroupId: "1_modification",
					run: function() {
						const lineNumber = editor.getPosition().lineNumber;
						if (finalResult == null)
							return;

						editor.pushUndoStop();
						editor.executeEdits("insert-result-all", [{
							range: new monaco.Range(lineNumber, Number.MAX_SAFE_INTEGER, lineNumber, Number.MAX_SAFE_INTEGER),
							text: "\n" + finalResult.toString()
						}]);
						editor.setPosition(new monaco.Position(lineNumber, Number.MAX_SAFE_INTEGER));
					}
				});

				editor.addAction({
					id: "insert-result-line",
					label: "Insert a New Line with the Result of the Current Line",
					keybindings: [],
					contextMenuGroupId: "1_modification",
					run: function() {
						const lineNumber = editor.getPosition().lineNumber;
						const result = lineResults[lineNumber - 1];
						if (result == null)
							return;

						editor.pushUndoStop();
						editor.executeEdits("insert-result-line", [{
							range: new monaco.Range(lineNumber, Number.MAX_SAFE_INTEGER, lineNumber, Number.MAX_SAFE_INTEGER),
							text: "\n" + result.toString()
						}]);
						editor.setPosition(new monaco.Position(lineNumber, Number.MAX_SAFE_INTEGER));
					}
				});

				window.editor = editor;

				editor.onDidChangeModelContent((event) => update());
				window.addEventListener("resize", () => {
					console.log({ width: window.innerWidth, height: window.innerHeight });
					editor.layout({ width: window.innerWidth, height: window.innerHeight });
				});

				let decorationKeys = new Set();
				function makeDecoration(key, options) {
					if (!decorationKeys.has(key)) {
						editor._codeEditorService.registerDecorationType("result", key, options);

						decorationKeys.add(key);
					}

					return editor._codeEditorService.resolveDecorationOptions(key, true);
				}

				math.config({
					number: "BigNumber",
					precision: 32
				});

				// Extra functions
				math.import({
					divmod: (x, n) => math.matrix([Math.floor(x / n), x % n])
				});

				let lineResults = [];
				let finalResult;

				let oldDecorations = [];
				function update() {
					const source = editor.getValue();
					const decorators = [];
					const usedKeys = new Set();
					const markers = [];
					let scope = new Map();

					let parsed;
					try {
						parsed = math.parse(source);
					} catch (exception) {
						// Add any exceptions as markers
						const column = exception.char - source.substring(0, exception.char - 1).lastIndexOf("\n") - 1;
						const lineNumber = source.substring(0, exception.char - 1).split("").filter(char => char === "\n").length + 1;
						markers.push({
							message: exception.message,
							startColumn: column,
							endColumn: column,
							startLineNumber: lineNumber,
							endLineNumber: lineNumber
						});
					}

					let nodes = [];
					if (source.trim() === "" || parsed === undefined) {
						nodes = [];
					} else if (parsed.type === "BlockNode") {
						nodes = parsed.blocks.map(block => block.node);
					} else {
						nodes = [parsed];
					}

					lineResults = [];

					let currentLine = 0;
					let sourceIndex = 0;

					function nextSourceCharacter() {
						let character;
						let comment = false;
						while (true) {
							character = source[sourceIndex++];
							if (character === "\n") {
								comment = false;
								currentLine++;
								continue;
							} else if (/\s/.test(character) || character === ";" || comment) {
								continue;
							} else if (character === "#") {
								comment = true;
								continue;
							}

							break;
						}

						return character;
					}

					// Match each node's "compiled" text with the source code.
					for (const node of nodes) {
						const compiled = node.toString().replace(/\s+/g, "");
						for (let i = 0; i < compiled.length; i++) {
							const next = nextSourceCharacter();
							if (next !== compiled[i]) {
								console.error("Can't match with source.");
								break;
							}
						}

						let result;
						try {
							result = node.evaluate(scope);
						} catch (exception) {
							markers.push({
								message: exception.message,
								startColumn: 1,
								endColumn: Number.MAX_SAFE_INTEGER,
								startLineNumber: currentLine + 1,
								endLineNumber: currentLine + 1
							});

							continue;
						}
						lineResults[currentLine] = result;

						// Result of this line
						scope.set(`l${currentLine + 1}`, result);
						scope.set(`line${currentLine + 1}`, result);

						// Result of the previous line
						scope.set("prev", result);
						scope.set("previous", result);
						scope.set("ans", result);
						scope.set("answer", result);

						if (typeof result === "function") {
							scope.set(result.name, result);
							continue;
						}

						// Add any results are decorators.
						const key = hashCode(result.toString());
						decorators.push({ range: new monaco.Range(currentLine + 1, Number.MAX_SAFE_INTEGER, currentLine + 1, Number.MAX_SAFE_INTEGER), options: makeDecoration(key, {
							after: {
								color: "gray",
								margin: "0 0 0 1em",
								textDecoration: "none",
								contentText: result.toString()
							}
						})});

						usedKeys.add(key);
					}

					try {
						finalResult = parser.evaluate(editor.getValue());
					} catch (exception) {
					}

					// Delta the new decorators
					oldDecorations = editor.deltaDecorations(oldDecorations, decorators);

					// Cleanup old keys
					for (const key of decorationKeys) {
						if (!usedKeys.has(key)) {
							editor._codeEditorService.removeDecorationType(key);
							decorationKeys.delete(key);
						}
					}

					// Set markers
					monaco.editor.setModelMarkers(editor.getModel(), "math", markers);

					// Put text in hidden textarea to persist data
					persistance.value = editor.getValue();
				}

				update();
			});
		</script>
	</body>
</html>